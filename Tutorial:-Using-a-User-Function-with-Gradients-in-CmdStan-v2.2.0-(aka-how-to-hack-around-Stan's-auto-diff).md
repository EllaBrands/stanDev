### Motivation

A number of Stan users have asked how to include a function that specifies gradients. This tutorial will cover one of the ways to get this done in Stan. We are planning to make this easier in the future.

The goal for this tutorial is to provide a quick way to hack in a user function as painlessly as possible. This method *does not* extend the Stan modeling language to include the user specified function. (Extending Stan's modeling language is possible, but much harder.)


### Prerequisites

0. Some familiarity with C++.
1. CmdStan v2.2.0. That's CmdStan, not RStan or PyStan.
2. Your function written in C++. This should be well tested.

### Overview

We're going to modify the C++ code generated by the CmdStan compiler. We'll walk through the steps first, then show how to do this with a concrete example.

#### Step 0. Build the CmdStan compiler.

You will only need to do this once. Once you download CmdStan and unpack it, run:
```
> make build -j2
```
(replace 2 with the number of cores you have or less if you don't have much memory)


#### Step 1. Create a skeleton Stan model.

We want Stan to take care of the input/output, variable transforms (Jacobian adjustments and error checking), and the rest of the boiler-plate code. We'll write a model that defines all the data, parameters, and the model excluding your user function. Once the data can be read in by the executable generated by the skeleton model, we can go to the next step.


#### Step 2. Set up your function.

We need to set up your user function so it can be included in the generated C++ code. We'll wrap the function in a call that can take in Stan's automatic differentiation types. We'll verify that we can call the function in a stand-alone test before moving forward.


#### Step 3. Alter the generated C++ code.

We'll hack the generated C++ code to call the user function. Compile.


#### Step 4. Run.

That's it. The executable will now call your function.


### Example: Normal distribution with mean as the parameter.

This is a toy example, but it should get you started.


#### Step 0. Build the CmdStan compiler.

If you can't run:
- on linux / mac: ` > bin/stanc` 
- on Windows: `> bin\stanc.exe`
then you haven't installed CmdStan properly. You can't really move on until you get past this step.


#### Step 1. Create a skeleton Stan model.

To stay organized, let's put this example in a folder called `normal-example`. 
1. Create the `normal-example` folder. (Run: `mkdir normal-example`.)
2. Create a data file in the folder. For example, put this inside `normal-example/normal.data.R`:
```
N <- 10
y <- c(0,1,2,3,4,5,6,7,8,9)
```
3. Create a skeleton Stan model. Put this inside `normal-example/normal.stan`:
```
data {
  int N;
  real y[N];
}
parameters {
  real mu;
}
model {
}
```
4. Compile the model. In linux / mac, it looks like: `make normal-example/normal`. In Windows, add `.exe` at the end.
5. Verify that the model can process the data. 
On linux/mac:
`> ./normal-example/normal sample algorithm=fixed_param data file=normal-example/normal.data.R`
On Windows:
`> normal-example\normal sample algorithm=fixed_param data file=normal-example/normal.data.R`
That will create an `output.csv` file with a random draw for the parameter `mu`.

If you can't verify step 5, do not continue.

#### Step 2. Set up your function.

So far, we haven't leveraged prerequisite 0, "Some familiarity with C++." We're going to start using it.

We'll assume you have two functions in a C++ header file, one to calculate the value, one to calculate the gradient. Let's assume we have this in `src/user_functions.hpp`:
```
#include <cmath> // for std::sqrt

double value(const double y, const double mu, const double sigma) {
  return 1.0 / (sigma * std::sqrt(2.0 * 3.1415927))
    * exp(-0.5 * (y - mu) * (y - mu) / (sigma * sigma));
}

double gradient_mu(const double y, const double mu, const double sigma) {
  return (y - mu) / (sigma * sigma) * value(y, mu, sigma);
}
```

These functions should be tested. We can use the Google testing framework to test this function. Here are some basic tests that should go in `src/test/user_functions_test.cpp`:
```
#include <gtest/gtest.h>
#include <user_functions.hpp>

TEST(user_functions, value) {
  EXPECT_FLOAT_EQ(0.39894228, value(0.0, 0.0, 1.0));
  EXPECT_FLOAT_EQ(0.24197072, value(0.0, 1.0, 1.0));
  EXPECT_FLOAT_EQ(0.11135304, value(1.2, 2.3, 3.4));
}

TEST(user_functions, finite_differences) {
  double d = 1e-8;
  double finite_diff;

  finite_diff = (value(0.0, 0.0 + d, 1.0) - value(0.0, 0.0 - d, 1.0)) / (2 * d);
  EXPECT_FLOAT_EQ(finite_diff, gradient_mu(0.0, 0.0, 1.0));
  
  finite_diff = (value(0.0, 1.0 + d, 1.0) - value(0.0, 1.0 - d, 1.0)) / (2 * d);
  EXPECT_FLOAT_EQ(finite_diff, gradient_mu(0.0, 1.0, 1.0));
  
  finite_diff = (value(1.2, 2.3 + d, 3.4) - value(1.2, 2.3 - d, 3.4)) / (2 * d);
  EXPECT_FLOAT_EQ(finite_diff, gradient_mu(1.2, 2.3, 3.4));
}
```
To run the tests, type:
on linux / mac: 
`> make test/user_functions`
on Windows:
`> make test/user_functions.exe`

We're ready to make these functions Stan compatiable. Just so you know what's coming up, we'll start by creating a templated function, then we'll create one template specialization that we'll end up using in the Stan generated C++ code.

First, add two Stan specific include to the top of `src/user_functions.hpp`:
```
#include <stan/agrad/rev/internal/precomputed_gradients.hpp>
#include <stan/meta/traits.hpp>
```
(The test should still compile and run.)

Now we'll define the templated function. Place this at the end of `src/user_functions.hpp`:
```
template <typename T1, typename T2, typename T3>
typename stan::return_type<T1,T2,T3>::type
user_normal(const T1& y, const T2& mu, const T3& sigma) {
  throw std::runtime_error("not implemented for these types");
}
```
(The test should compile and run.)

Let's add some tests. We're going to make sure all instantiations of the function throws an exception. (It's not necessary to check all instantiations, but it illustrates the generality of the functions exposed in the Stan modeling language.) Add this test to the end of the test file:
```
TEST(user_functions, user_normal_exception) {
  double y_d = 0, mu_d = 0, sigma_d = 1;
  stan::agrad::var y_v = 0, mu_v = 0, sigma_v = 1;

  EXPECT_THROW(user_normal(y_d, mu_d, sigma_d), std::runtime_error);
  EXPECT_THROW(user_normal(y_d, mu_d, sigma_v), std::runtime_error);
  EXPECT_THROW(user_normal(y_d, mu_v, sigma_d), std::runtime_error);
  EXPECT_THROW(user_normal(y_d, mu_v, sigma_v), std::runtime_error);
  EXPECT_THROW(user_normal(y_v, mu_d, sigma_d), std::runtime_error);
  EXPECT_THROW(user_normal(y_v, mu_d, sigma_v), std::runtime_error);
  EXPECT_THROW(user_normal(y_v, mu_v, sigma_d), std::runtime_error);
  EXPECT_THROW(user_normal(y_v, mu_v, sigma_v), std::runtime_error);
}
```

In the Stan modeling language, variables defined in the data and transformed data blocks are represented in C++ by `double` and the variables defined in the parameters and transformed parameters blocks are represented by auto-diff variables, `stan::agrad::var`.

We'll now specialize the template function with the types we expect. Add this to the end of `src/user_functions.hpp`:
```
template <>
stan::agrad::var
user_normal(const double& y, const stan::agrad::var& mu, const double& sigma) {
  double val = value(y, mu.val(), sigma);
  double grad = gradient_mu(y, mu.val(), sigma);

  std::vector<stan::agrad::var> vars;
  vars.push_back(mu);
  
  std::vector<double> gradients;
  gradients.push_back(grad);

  return stan::agrad::precomputed_gradients(val, vars, gradients);
}
```
If you compile and run the tests, it should fail when the arguments are `(double, stan::agrad::var, double)`. Change this line:
`EXPECT_THROW(user_normal(y_d, mu_v, sigma_d), std::runtime_error);`
to:
`EXPECT_NO_THROW(user_normal(y_d, mu_v, sigma_d));`

Finally, before we move on, let's test our new function.
```
TEST(user_functions, user_normal) {
  double y = 1.2;
  stan::agrad::var mu = 2.3;
  double sigma = 3.4;
  
  stan::agrad::var result = user_normal(y, mu, sigma);
  std::vector<stan::agrad::var> vars;
  vars.push_back(mu);
 
  std::vector<double> gradients;
  
  EXPECT_FLOAT_EQ(0.11135304, result.val());
  EXPECT_NO_THROW(result.grad(vars, gradients));
  ASSERT_EQ(1U, gradients.size());
  EXPECT_FLOAT_EQ(-0.010595878, gradients[0]);
}
```
Rerun the tests. Make sure it all passes before going on.

#### Step 3. Alter the generated C++ code.

Now that we have a model that can parse the data and a function that can be included, we're going to alter the generated C++ code.

Open `normal-example/normal.cpp`. We'll first include the header we defined. Add this to the top:
```
#include <user_functions.hpp>
```

We're now going to modify the `log_prob` function to call the templated function we defined in Step 2.

Search for the `log_prob` function. Within that function, there's a `// model body` comment. This is where we'll inject code.

At this point, we have access to all the variables we defined in the data, transformed data, parameters, and transformed parameters blocks. They are named what you named them in the Stan model.

Let's build the model. In that section, add:
```
  for (size_t n = 0; n < N; n++) {
    lp_accum__.add(log(user_normal(y[n], mu, 3.0)));
  }
```

A few things to note:
1. C++ is 0-indexed.
2. We defined the normal distribution on the linear scale, so we had to take the log. This will do the correct thing, but is slower than if we had defined our function on the log scale.
3. We use a fixed sigma in the code. We didn't define it in our skeleton Stan model, so there's no sigma to use in the generated C++.

Build the model from the command line:
on linux / mac:
`> make normal-example/normal`
on Windows:
`> make normal-example/normal.exe`

If there are any compiler errors, fix them before moving on. If things compiled correctly, you're ready to move on.


#### Step 4. Run.
On linux / mac:
`> ./normal-example/normal sample data file=normal-example/normal.data.R`
On Windows:
`> normal-example\normal sample data file=normal-example/normal.data.R`

Check `output.csv`. The posterior mean of mu should be 4.5.

That's it. You've successfully hacked your own function into a Stan model.

If you want to see the final files:
[src/user_functions.hpp](https://gist.github.com/syclik/8970060#file-user_functions-hpp)
[src/test/user_functions_test.cpp](https://gist.github.com/syclik/8970060#file-user_functions_test-cpp)
[normal-example/normal.cpp (edited)](https://gist.github.com/syclik/8970060#file-normal-cpp)